<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Immersion Tracker — Japanese × Spanish (Streak Edition)</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen">
  <div id="root"></div>

  <!-- React + ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    /* --------------------
       Full tracker code
       (all functions, UI, logic, persistence)
       -------------------- */

    const STORAGE_KEY = "immersion-tracker-v2";

    function todayISO(d = new Date()) {
      const tzOffset = d.getTimezoneOffset();
      const local = new Date(d.getTime() - tzOffset * 60000);
      return local.toISOString().slice(0, 10);
    }

    function shiftISO(dateStr, deltaDays) {
      const d = new Date(dateStr + "T00:00:00");
      d.setDate(d.getDate() + deltaDays);
      return todayISO(d);
    }

    function startOfISOWeek(date = new Date()) {
      const d = new Date(date);
      const day = (d.getDay() + 6) % 7; // Mon=0
      d.setHours(0, 0, 0, 0);
      d.setDate(d.getDate() - day);
      return d;
    }

    function weekId(date = new Date()) {
      const start = startOfISOWeek(date);
      return todayISO(start);
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    const defaultConfig = {
      goals: {
        ja: { watch: 30, read: 20, mine: 5, anki: true, wanikani: true },
        es: { watch: 30, listen: 20, read: 15, mine: 5, anki: false },
      },
      weekly: { vanessaHomework: true },
      ui: { compact: false, accent: "emerald" },
    };

    function safeGetLocalStorage() {
      try {
        if (typeof window !== "undefined" && window.localStorage) return window.localStorage;
      } catch (_) {}
      return { getItem: () => null, setItem: () => {}, removeItem: () => {} };
    }

    const LS = safeGetLocalStorage();

    function migrateState(raw) {
      const base = { config: defaultConfig, entries: {}, weekly: {}, meta: { bestStreak: 0 } };
      if (!raw || typeof raw !== "object") return base;
      const cfg = { ...defaultConfig, ...(raw.config || {}) };
      return {
        config: cfg,
        entries: raw.entries || {},
        weekly: raw.weekly || {},
        meta: { bestStreak: 0, ...(raw.meta || {}) },
      };
    }

    function loadState() {
      try {
        const raw = LS.getItem(STORAGE_KEY);
        if (!raw) return { config: defaultConfig, entries: {}, weekly: {}, meta: { bestStreak: 0 } };
        return migrateState(JSON.parse(raw));
      } catch {
        return { config: defaultConfig, entries: {}, weekly: {}, meta: { bestStreak: 0 } };
      }
    }

    function saveState(s) {
      try { LS.setItem(STORAGE_KEY, JSON.stringify(s)); } catch {}
    }

    function usePersistentState() {
      const [state, setState] = useState(loadState);
      useEffect(() => saveState(state), [state]);
      return [state, setState];
    }

    function Ring({ label, value, goal }) {
      const pct = goal > 0 ? clamp((value / goal) * 100, 0, 100) : 0;
      const bg = `conic-gradient(currentColor ${pct}%, rgba(255,255,255,0.06) ${pct}%)`;
      return (
        <div className="flex flex-col items-center justify-center">
          <div className="w-28 h-28 rounded-full grid place-items-center text-white" style={{ background: bg }}>
            <div className="w-24 h-24 rounded-full bg-neutral-950/80 backdrop-blur grid place-items-center border border-white/10">
              <div className="text-center">
                <div className="text-xl font-semibold">{Math.round(pct)}%</div>
                <div className="text-xs text-neutral-400">{label}</div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function NumberInput({ value, onChange, min = 0, max = 600, step = 5, suffix }) {
      return (
        <div className="flex items-center gap-2">
          <button onClick={() => onChange(clamp((value || 0) - step, min, max))}>−{step}</button>
          <input type="number" value={value ?? 0} onChange={(e) => onChange(clamp(parseInt(e.target.value || "0", 10), min, max))}/>
          {suffix}
          <button onClick={() => onChange(clamp((value || 0) + step, min, max))}>+{step}</button>
        </div>
      );
    }

    function Toggle({ checked, onChange, label }) {
      return (
        <label>
          <input type="checkbox" checked={checked} onChange={(e) => onChange(e.target.checked)} />
          {label}
        </label>
      );
    }

    function SectionCard({ title, children, right }) {
      return (
        <div className="rounded-2xl bg-neutral-900/50 p-5 border border-white/10">
          <div className="flex justify-between mb-4">
            <h2>{title}</h2>{right}
          </div>{children}
        </div>
      );
    }

    function isDayComplete(entry, goals) {
      if (!entry) return false;
      const jaTimeGoal = goals.ja.watch + goals.ja.read;
      const jaTimeDone = entry.ja.watch + entry.ja.read;
      const esTimeGoal = goals.es.watch + goals.es.listen + goals.es.read;
      const esTimeDone = entry.es.watch + entry.es.listen + entry.es.read;
      const ja = (!goals.ja.wanikani || entry.ja.wanikani) && (!goals.ja.anki || entry.ja.anki) && jaTimeDone >= jaTimeGoal && entry.ja.mine >= goals.ja.mine;
      const es = (!goals.es.anki || entry.es.anki) && esTimeDone >= esTimeGoal && entry.es.mine >= goals.es.mine;
      return ja && es;
    }

    function computeStreak(entries, goals, endDateISO) {
      let streak = 0, cursor = endDateISO;
      while (true) {
        const e = entries[cursor];
        if (!e || !isDayComplete(e, goals)) break;
        streak += 1;
        cursor = shiftISO(cursor, -1);
      }
      return streak;
    }

    function computeBestStreak(entries, goals) {
      const dates = Object.keys(entries).sort();
      let best = 0;
      const set = new Set(dates);
      for (const d of dates) {
        const prev = shiftISO(d, -1);
        if (set.has(prev)) continue;
        let cur = d, len = 0;
        while (set.has(cur) && isDayComplete(entries[cur], goals)) {
          len++; cur = shiftISO(cur, -1);
        }
        best = Math.max(best, len);
      }
      return best;
    }

    function ImmersionTracker() {
      const [state, setState] = usePersistentState();
      const [date, setDate] = useState(todayISO());
      const goals = state.config.goals;
      const entry = state.entries[date] || { ja:{watch:0,read:0,mine:0,anki:false,wanikani:false}, es:{watch:0,listen:0,read:0,mine:0,anki:false}, notes:"" };
      const dailyComplete = isDayComplete(entry, goals);
      const currentStreak = computeStreak(state.entries, goals, date);
      const bestStreak = computeBestStreak(state.entries, goals);

      return (
        <div className="p-6 text-white">
          <h1>Immersion Tracker</h1>
          <p>Date: {date}</p>
          <p>Current streak: {currentStreak} days (best {bestStreak})</p>
          <p>{dailyComplete ? "✅ Complete" : "❌ Not complete"}</p>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<ImmersionTracker />);
  </script>
</body>
</html>
