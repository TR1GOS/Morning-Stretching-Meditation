<!DOCTYPE html>
<html lang="en" class="h-full bg-neutral-950">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Immersion Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-full text-neutral-100 bg-[radial-gradient(circle_at_20%_0%,#0f1117_0%,#0b0d12_40%,#0a0b0f_100%)]">
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
      // === Immersion Tracker Code ===

      const STORAGE_KEY = "immersion-tracker-v2";

      // -------------------- Date & Helpers --------------------
      function todayISO(d = new Date()) {
        const tzOffset = d.getTimezoneOffset();
        const local = new Date(d.getTime() - tzOffset * 60000);
        return local.toISOString().slice(0, 10);
      }
      function shiftISO(dateStr, deltaDays) {
        const d = new Date(dateStr + "T00:00:00");
        d.setDate(d.getDate() + deltaDays);
        return todayISO(d);
      }
      function startOfISOWeek(date = new Date()) {
        const d = new Date(date);
        const day = (d.getDay() + 6) % 7;
        d.setHours(0, 0, 0, 0);
        d.setDate(d.getDate() - day);
        return d;
      }
      function weekId(date = new Date()) {
        const start = startOfISOWeek(date);
        return start.toISOString().slice(0, 10);
      }
      function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      // -------------------- Config & Persistence --------------------
      const defaultConfig = {
        goals: {
          ja: { watch: 30, read: 20, mine: 5, anki: true, wanikani: true },
          es: { watch: 30, listen: 20, read: 15, mine: 5, anki: false },
        },
        weekly: { vanessaHomework: true },
        ui: { compact: false, accent: "emerald" },
      };

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return { config: defaultConfig, entries: {}, weekly: {}, meta: { bestStreak: 0 } };
          const parsed = JSON.parse(raw);
          return {
            config: { ...defaultConfig, ...(parsed.config || {}) },
            entries: parsed.entries || {},
            weekly: parsed.weekly || {},
            meta: parsed.meta || { bestStreak: 0 },
          };
        } catch (e) {
          return { config: defaultConfig, entries: {}, weekly: {}, meta: { bestStreak: 0 } };
        }
      }
      function saveState(s) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
      }
      function usePersistentState() {
        const [state, setState] = React.useState(loadState);
        React.useEffect(() => saveState(state), [state]);
        return [state, setState];
      }

      // -------------------- UI Primitives --------------------
      function Ring({ label, value, goal }) {
        const pct = goal > 0 ? clamp((value / goal) * 100, 0, 100) : 0;
        const bg = `conic-gradient(currentColor ${pct}%, rgba(255,255,255,0.06) ${pct}%)`;
        return (
          <div className="flex flex-col items-center justify-center">
            <div className="w-28 h-28 rounded-full grid place-items-center text-white" style={{ background: bg }}>
              <div className="w-24 h-24 rounded-full bg-neutral-950/80 backdrop-blur grid place-items-center border border-white/10">
                <div className="text-center">
                  <div className="text-xl font-semibold">{Math.round(pct)}%</div>
                  <div className="text-xs text-neutral-400">{label}</div>
                </div>
              </div>
            </div>
          </div>
        );
      }
      function NumberInput({ value, onChange, min = 0, max = 600, step = 5, suffix }) {
        return (
          <div className="flex items-center gap-2">
            <button className="px-2 py-1 rounded-lg bg-neutral-900/70 hover:bg-neutral-800/80 border border-white/10" onClick={() => onChange(clamp((value || 0) - step, min, max))}>âˆ’{step}</button>
            <input className="w-24 px-3 py-2 rounded-lg bg-neutral-900/70 border border-white/10 focus:outline-none focus:ring-2 focus:ring-white/20" type="number" value={value ?? 0} onChange={(e) => onChange(clamp(parseInt(e.target.value || "0", 10), min, max))} min={min} max={max} step={1} />
            {suffix && <span className="text-neutral-400 text-sm">{suffix}</span>}
            <button className="px-2 py-1 rounded-lg bg-neutral-900/70 hover:bg-neutral-800/80 border border-white/10" onClick={() => onChange(clamp((value || 0) + step, min, max))}>+{step}</button>
          </div>
        );
      }
      function Toggle({ checked, onChange, label }) {
        return (
          <label className="flex items-center gap-3 cursor-pointer select-none">
            <span className={`w-12 h-7 rounded-full p-1 transition-colors ${checked ? "bg-emerald-500" : "bg-neutral-700/70"}`} onClick={() => onChange(!checked)}>
              <span className={`block w-5 h-5 rounded-full bg-white transition-transform ${checked ? "translate-x-5" : "translate-x-0"}`}></span>
            </span>
            <span className="text-sm text-neutral-200">{label}</span>
          </label>
        );
      }
      function SectionCard({ title, children, right }) {
        return (
          <div className="rounded-2xl bg-neutral-900/50 backdrop-blur border border-white/10 shadow-[0_0_0_1px_rgba(255,255,255,0.04)] p-5">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold text-white tracking-wide">{title}</h2>
              {right}
            </div>
            {children}
          </div>
        );
      }

      // -------------------- Logic: Completion & Streaks --------------------
      function isDayComplete(entry, goals) {
        if (!entry) return false;
        const jaTimeGoal = (goals.ja.watch || 0) + (goals.ja.read || 0);
        const jaTimeDone = (entry.ja.watch || 0) + (entry.ja.read || 0);
        const esTimeGoal = (goals.es.watch || 0) + (goals.es.listen || 0) + (goals.es.read || 0);
        const esTimeDone = (entry.es.watch || 0) + (entry.es.listen || 0) + (entry.es.read || 0);
        const ja = (!goals.ja.wanikani || entry.ja.wanikani) && (!goals.ja.anki || entry.ja.anki) && jaTimeDone >= jaTimeGoal && (entry.ja.mine || 0) >= (goals.ja.mine || 0);
        const es = (!goals.es.anki || entry.es.anki) && esTimeDone >= esTimeGoal && (entry.es.mine || 0) >= (goals.es.mine || 0);
        return ja && es;
      }
      function computeStreak(entries, goals, endDateISO) {
        let streak = 0;
        let cursor = endDateISO;
        while (true) {
          const e = entries[cursor];
          if (!e || !isDayComplete(e, goals)) break;
          streak += 1;
          cursor = shiftISO(cursor, -1);
        }
        return streak;
      }
      function computeBestStreak(entries, goals) {
        const dates = Object.keys(entries).sort();
        let best = 0;
        if (dates.length === 0) return 0;
        const set = new Set(dates);
        for (const d of dates) {
          const prev = shiftISO(d, -1);
          if (set.has(prev)) continue;
          let cur = d;
          let len = 0;
          while (set.has(cur) && isDayComplete(entries[cur], goals)) {
            len += 1;
            cur = shiftISO(cur, -1);
          }
          if (len > best) best = len;
        }
        return best;
      }

      // -------------------- App --------------------
      function ImmersionTracker() {
        const [state, setState] = usePersistentState();
        const [date, setDate] = React.useState(todayISO());
        const wId = React.useMemo(() => weekId(new Date(date)), [date]);

        React.useEffect(() => {
          setState((prev) => {
            const entries = { ...prev.entries };
            if (!entries[date]) {
              entries[date] = { ja: { watch: 0, read: 0, mine: 0, anki: false, wanikani: false }, es: { watch: 0, listen: 0, read: 0, mine: 0, anki: false }, notes: "" };
            }
            const weekly = { ...prev.weekly };
            if (!weekly[wId]) weekly[wId] = { vanessa: false };
            const meta = prev.meta || { bestStreak: 0 };
            return { ...prev, entries, weekly, meta };
          });
        }, [date]);

        const entry = state.entries[date];
        const weeklyState = state.weekly[wId] || { vanessa: false };
        const goals = state.config.goals;

        const jaTimeGoal = (goals.ja.watch || 0) + (goals.ja.read || 0);
        const jaTimeDone = (entry.ja.watch || 0) + (entry.ja.read || 0);
        const esTimeGoal = (goals.es.watch || 0) + (goals.es.listen || 0) + (goals.es.read || 0);
        const esTimeDone = (entry.es.watch || 0) + (entry.es.listen || 0) + (entry.es.read || 0);

        const dailyComplete = isDayComplete(entry, goals);
        const currentStreak = computeStreak(state.entries, goals, date);
        const bestStreakCalc = computeBestStreak(state.entries, goals);
        React.useEffect(() => {
          if ((state.meta?.bestStreak || 0) < bestStreakCalc) {
            setState((prev) => ({ ...prev, meta: { ...(prev.meta || {}), bestStreak: bestStreakCalc } }));
          }
        }, [bestStreakCalc]);

        const changeDate = (deltaDays) => setDate((d) => shiftISO(d, deltaDays));

        const setEntry = (path, value) => {
          setState((prev) => {
            const entries = { ...prev.entries };
            const e = entries[date];
            const newEntry = JSON.parse(JSON.stringify(e));
            const keys = path.split(".");
            let cur = newEntry;
            for (let i = 0; i < keys.length - 1; i++) {
              const k = keys[i];
              if (typeof cur[k] !== "object" || cur[k] === null) cur[k] = {};
              cur = cur[k];
            }
            cur[keys[keys.length - 1]] = value;
            entries[date] = newEntry;
            return { ...prev, entries };
          });
        };

        return (
          <div className="min-h-screen p-6">
            <h1 className="text-2xl font-bold mb-4">Immersion Tracker</h1>
            <div className="mb-4">Date: {date} | Streak: {currentStreak}d | Best: {state.meta.bestStreak}d</div>
            <SectionCard title="Japanese">
              <div className="space-y-2">
                <div>Watch</div>
                <NumberInput value={entry.ja.watch} onChange={(v) => setEntry("ja.watch", v)} suffix="min" />
                <div>Read</div>
                <NumberInput value={entry.ja.read} onChange={(v) => setEntry("ja.read", v)} suffix="min" />
                <div>Mine</div>
                <NumberInput value={entry.ja.mine} onChange={(v) => setEntry("ja.mine", v)} step={1} suffix="items" />
              </div>
            </SectionCard>
            <SectionCard title="Spanish">
              <div className="space-y-2">
                <div>Watch</div>
                <NumberInput value={entry.es.watch} onChange={(v) => setEntry("es.watch", v)} suffix="min" />
                <div>Listen</div>
                <NumberInput value={entry.es.listen} onChange={(v) => setEntry("es.listen", v)} suffix="min" />
                <div>Read</div>
                <NumberInput value={entry.es.read} onChange={(v) => setEntry("es.read", v)} suffix="min" />
                <div>Mine</div>
                <NumberInput value={entry.es.mine} onChange={(v) => setEntry("es.mine", v)} step={1} suffix="items" />
              </div>
            </SectionCard>
          </div>
        );
      }

      // -------------------- Render --------------------
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<ImmersionTracker />);
    </script>
  </body>
</html>
